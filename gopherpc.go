package gopherpc

import (
	"bytes"
	"errors"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"html/template"
	"io"
	"log"
	"strings"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

var (
	defaultOutputTemplate = template.Must(template.New("").Parse(`// +build !js js,wasm

// This file was autogenerated by gopherpc.

package {{.PackageName}}

import (
	"bytes"
	"errors"
	"net/http"
)

{{range $service := .Services}}
type {{$service.ClientName}} struct {
	// Endpoint is the endpoint to send RPC requests to.
	Endpoint string

	// CSRFToken is the CSRF token to include with each request.
	CSRFToken string

	// Encoding specifies the encoding of messages sent to and from the
	// RPC server. To use the included JSON implementation, set this to
	// new(json.Encoding).
	Encoding interface {
		// EncodeRequest takes a method name like "Service.Method" and an argument
		// and returns the body of the request to be sent.
		EncodeRequest(serviceMethod string, arg interface{}) ([]byte, error)
		// DecodeResponse decodes the response body represented by r into reply.
		DecodeResponse(r io.Reader, reply interface{}) error
		// ContentType returns the content type that this encoding should set.
		ContentType() string
	}

	HttpClient http.Client
}

func (s {{$service.ClientName}}) call(method string, arg, ret interface{}) error {
	if s.Encoding == nil {
		return errors.New("no rpc encoding specified!")
	}

	message, err := s.Encoding.EncodeRequest("{{$service.Name}}." + method, arg)
	if err != nil {
		return errors.New("failed to encode request argument: " + err.Error())
	}

	req, err := http.NewRequest("POST", s.Endpoint, bytes.NewReader(message))
	if err != nil {
		return errors.New("failed to construct request: " + err.Error())
	}

	req.Header.Add("X-CSRF-Token", s.CSRFToken)
	req.Header.Add("Content-Type", s.Encoding.ContentType())

	resp, err := s.HttpClient.Do(req)
	if err != nil {
		return errors.New("failed to execute request: " + err.Error())
	}
	defer resp.Body.Close()

	if err := s.Encoding.DecodeResponse(resp.Body, ret); err != nil {
		return errors.New("failed to decode response: " + err.Error())
	}

	return nil
}

{{range $method := $service.Methods}}
func (s {{$service.ClientName}}) {{$method.Name}}({{$method.Params}}) {{$method.Return}} {
{{- if .ReturnType}}
	var reply {{$method.ReturnType}}
	err := s.call("{{$method.Name}}", {{$method.ParamNameOrNil}}, &reply)
	return reply, err
{{- else}}
	return s.call("{{$method.Name}}", {{$method.ParamNameOrNil}}, nil)
{{- end}}
}
{{end}}

{{end}}
`))

	jsOutputTemplate = template.Must(template.New("").Parse(`// +build js,!wasm

// This file was autogenerated by gopherpc.

package {{.PackageName}}

import (
	"errors"

	"honnef.co/go/js/xhr"
)

{{range $service := .Services}}
type {{$service.ClientName}} struct {
	// Endpoint is the endpoint to send RPC requests to.
	Endpoint string

	// CSRFToken is the CSRF token to include with each request.
	CSRFToken string

	// Encoding specifies the encoding of messages sent to and from the
	// RPC server. To use the included JSON implementation, set this to
	// json.Encoding{}.
	Encoding interface {
		// EncodeRequest takes a method name like "Service.Method" and an argument
		// and returns the body of the request to be sent.
		EncodeRequest(serviceMethod string, arg interface{}) ([]byte, error)
		// DecodeResponse decodes the response body represented by r into reply.
		DecodeResponse(r io.Reader, reply interface{}) error
	}
}

func (s {{$service.ClientName}}) call(method string, arg, ret interface{}) error {
	if s.Encoding == nil {
		return errors.New("no rpc encoding specified!")
	}

	message, err := s.Encoding.EncodeRequest("{{$service.Name}}." + method, arg)
	if err != nil {
		return err
	}

	req := xhr.NewRequest("POST", s.Endpoint)
	req.SetRequestHeader("X-CSRF-Token", s.CSRFToken)
	req.SetRequestHeader("Content-Type", "application/json")
	if err := req.Send(message); err != nil {
		return err
	}

	return s.Encoding.DecodeResponse(strings.NewReader(req.ResponseText), &ret)
}

{{range $method := $service.Methods}}
func (s {{$service.ClientName}}) {{$method.Name}}({{$method.Params}}) {{$method.Return}} {
{{- if .ReturnType}}
	var reply {{$method.ReturnType}}
	err := s.call("{{$service.Name}}.{{$method.Name}}", {{$method.ParamNameOrNil}}, &reply)
	return reply, err
{{- else}}
	return s.call("{{$service.Name}}.{{$method.Name}}", {{$method.ParamNameOrNil}}, nil)
{{- end}}
}
{{end}}

{{end}}
`))
)

type TemplateData struct {
	PackageName string
	Services    []Service
}

type Mode int

const (
	Default Mode = iota
	Js
)

func NewMode(s string) (Mode, error) {
	switch s {
	case "js":
		return Js, nil
	case "", "default":
		return Default, nil
	default:
		return Default, errors.New("unknown mode: " + s)
	}
}

func (m Mode) Template() *template.Template {
	switch m {
	case Js:
		return jsOutputTemplate
	case Default:
		return defaultOutputTemplate
	default:
		panic("unreachable")
	}
}

func Gen(pkg *packages.Package, outputPackageName string, w io.Writer, mode Mode) error {
	if len(pkg.Errors) > 0 {
		for _, err := range pkg.Errors {
			log.Println("  " + err.Error())
		}
		return errors.New("pkg contained errors")
	}

	if outputPackageName == "" {
		outputPackageName = pkg.Name
	}

	var toProcess []*ast.Ident
	for _, f := range pkg.Syntax {
		for _, decl := range f.Decls {
			if name := isRPCService(decl); name != nil {
				toProcess = append(toProcess, name)
			}
		}
	}

	td := TemplateData{PackageName: outputPackageName}

	for _, name := range toProcess {
		td.Services = append(td.Services, newService(pkg, name))
	}

	var buf bytes.Buffer
	if err := mode.Template().Execute(&buf, td); err != nil {
		return errors.New("error executing output template: " + err.Error())
	}

	processed, err := imports.Process("rpc.go", buf.Bytes(), nil)
	if err != nil {
		return errors.New("error processing imports: " + err.Error())
	}

	formatted, err := format.Source(processed)
	if err != nil {
		return errors.New("error formatting source: " + err.Error())
	}

	if _, err := w.Write(formatted); err != nil {
		return errors.New("error writing output: " + err.Error())
	}

	return nil
}

// isRPCService returns a valid identifier if the declaration represents
// an RPC service, otherwise nil.
func isRPCService(decl ast.Decl) *ast.Ident {
	if gen, ok := decl.(*ast.GenDecl); ok && gen.Tok == token.TYPE {
		if strings.Contains(gen.Doc.Text(), "gopherpc:generate") {
			return gen.Specs[0].(*ast.TypeSpec).Name
		}
	}
	return nil
}

func newService(pkg *packages.Package, name *ast.Ident) Service {
	serviceType := pkg.TypesInfo.Defs[name].Type().(*types.Named)
	service := Service{
		Name:       serviceType.Obj().Name(),
		ClientName: serviceType.Obj().Name() + "Client",
	}
	log.Printf("processing service %s", service.Name)

loop:
	for i := 0; i < serviceType.NumMethods(); i++ {
		var (
			m          = serviceType.Method(i)
			sig        = m.Type().(*types.Signature)
			sigParams  = sig.Params()
			sigResults = sig.Results()
		)
		log.Printf(" -- %s", m.Name())

		if sigParams.Len() != 3 {
			log.Printf("skipping %s.%s because it doesn't have 3 parameters", service.Name, m.Name())
			continue loop
		}

		if sigResults.Len() != 1 {
			log.Printf("skipping %s.%s because it doesn't return exactly 1 value\n", service.Name, m.Name())
			continue loop
		}

		if sigResults.At(0).Type().(*types.Named).Obj().Name() != "error" {
			log.Printf("skipping %s.%s because its return value isnt an error\n", service.Name, m.Name())
			continue loop
		}

		var paramTypes []types.Type
		for j := 0; j < 3; j++ {
			if t, ok := sigParams.At(j).Type().(*types.Pointer); !ok {
				log.Printf("skipping %s.%s because parameter %d isn't a pointer\n", service.Name, m.Name(), j)
				continue loop
			} else {
				paramTypes = append(paramTypes, t.Elem())
			}
		}

		if t, ok := paramTypes[0].(*types.Named); !ok || t.Obj().Pkg().Path() != "net/http" || t.Obj().Name() != "Request" {
			log.Printf("skipping %s.%s because its first parameter isn't an *http.Request\n", service.Name, m.Name())
			continue loop
		}

		method := Method{Name: m.Name()}

		param := sig.Params().At(1)
		method.ParamName = param.Name()
		if method.ParamName != "_" {
			switch t := param.Type().(*types.Pointer).Elem().(type) {
			case *types.Named:
				if t.Obj().Pkg().Path() == pkg.Types.Path() {
					method.ParamType = "*" + t.Obj().Name()
				} else {
					method.ParamType = "*" + t.Obj().Pkg().Name() + "." + t.Obj().Name()
				}
			case *types.Basic:
				method.ParamType = t.Name()
			default:
				log.Fatal("unknown pointer type")
			}
		}

		returnValue := sig.Params().At(2)
		if returnValue.Name() != "_" {
			switch t := returnValue.Type().(*types.Pointer).Elem().(type) {
			case *types.Named:
				method.ReturnType = "*" + t.Obj().Pkg().Name() + "." + t.Obj().Name()
			case *types.Basic:
				method.ReturnType = t.Name()
			default:
				log.Fatal("unknown pointer type")
			}
		}

		service.Methods = append(service.Methods, method)
	}

	return service
}

type Service struct {
	Name       string
	ClientName string
	Methods    []Method
}

type Method struct {
	Name                 string
	ParamName, ParamType string
	ReturnType           string
}

func (m Method) Params() string {
	if m.ParamType == "" {
		return ""
	}
	return m.ParamName + " " + m.ParamType
}

func (m Method) ParamNameOrNil() string {
	if m.ParamType == "" {
		return "nil"
	}
	return m.ParamName
}

func (m Method) Return() string {
	if m.ReturnType == "" {
		return "error"
	}
	return "(" + m.ReturnType + ", error)"
}
