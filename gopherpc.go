package gopherpc

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"html/template"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/imports"
)

var (
	outputTemplate = template.Must(template.New("").Parse(`// +build js

// This file was autogenerated by gopherpc.

package {{.PackageName}}

import (
	"honnef.co/go/js/xhr"
)

// Client represents a handle to an RPC endpoint.
type Client struct {
	// URL is the endpoint to send RPC requests to.
	URL string

	// CSRFToken is the CSRF token to include with each request.
	CSRFToken string

	// Encoding specifies the encoding of messages sent to and from the
	// RPC server. To use the included JSON implementation, set this to
	// json.Encoding{}.
	Encoding interface {
		// EncodeRequest takes a method name like "Service.Method" and an argument
		// and returns the body of the request to be sent.
		EncodeRequest(serviceMethod string, arg interface{}) ([]byte, error)
		// DecodeResponse decodes the response body represented by r into reply.
		DecodeResponse(r io.Reader, reply interface{}) error
	}
}

func (c Client) call(serviceMethod string, arg, ret interface{}) error {
	message, err := c.Encoding.EncodeRequest(serviceMethod, arg)
	if err != nil {
		return err
	}

	req := xhr.NewRequest("POST", c.URL)
	req.SetRequestHeader("X-CSRF-Token", c.CSRFToken)
	req.SetRequestHeader("Content-Type", "application/json")
	if err := req.Send(message); err != nil {
		return err
	}

	return c.Encoding.DecodeResponse(strings.NewReader(req.ResponseText), &ret)
}

{{range $service := .Services}}
type {{$service.Name}} struct { Client }

func (c Client) {{$service.Name}}() {{$service.Name}} {
	return {{$service.Name}}{c}
}

{{range $method := $service.Methods}}
func (s {{$service.Name}}) {{$method.Name}}({{$method.Params}}) {{$method.Return}} {
{{- if .ReturnType}}
	var reply {{$method.ReturnType}}
	err := s.call("{{$service.Name}}.{{$method.Name}}", {{$method.ParamNameOrNil}}, &reply)
	return reply, err
{{- else}}
	return s.call("{{$service.Name}}.{{$method.Name}}", {{$method.ParamNameOrNil}}, nil)
{{- end}}
}
{{end}}

{{end}}
`))
)

type TemplateData struct {
	PackageName string
	Services    []Service
}

type GenArgs struct {
	// Verbose can be set to true to get more logging output.
	Verbose bool
	// Out determines where the result will be written.
	Out io.Writer
	// SrcPackage is the path of the package to be scanned. Any declarations
	// in this package with a comment beginning with "rpc:gen" will be
	// included for generation.
	SrcPackage string
	// PackageName is the name of the output package.
	PackageName string
}

func Gen(args GenArgs) error {
	pkg, err := build.Import(args.SrcPackage, findSrcDir(args.SrcPackage), 0)
	if err != nil {
		return errors.New("failed to import package: " + err.Error())
	}

	var (
		fset      = token.NewFileSet()
		asts      []*ast.File
		toProcess []*ast.Ident
	)
	for _, filename := range pkg.GoFiles {
		f, err := parser.ParseFile(fset, filepath.Join(pkg.Dir, filename), nil, parser.ParseComments)
		if err != nil {
			panic(err)
		}
		asts = append(asts, f)

		for _, decl := range f.Decls {
			if name := isRPCService(decl); name != nil {
				toProcess = append(toProcess, name)
			}
		}
	}

	var (
		info        = types.Info{Defs: make(map[*ast.Ident]types.Object)}
		typesConfig = types.Config{Importer: importer.For("source", nil)}
	)

	if _, err := typesConfig.Check(pkg.Dir, fset, asts, &info); err != nil {
		return errors.New("error type-checking source file: " + err.Error())
	}

	td := TemplateData{
		PackageName: args.PackageName,
	}

	for _, name := range toProcess {
		td.Services = append(td.Services, newService(info.Defs[name].Type().(*types.Named), args.Verbose))
	}

	var buf bytes.Buffer
	if err := outputTemplate.Execute(&buf, td); err != nil {
		return errors.New("error executing output template: " + err.Error())
	}

	processed, err := imports.Process("rpc.go", buf.Bytes(), nil)
	if err != nil {
		return errors.New("error processing imports: " + err.Error())
	}

	formatted, err := format.Source(processed)
	if err != nil {
		return errors.New("error formatting source: " + err.Error())
	}

	if _, err := args.Out.Write(formatted); err != nil {
		return errors.New("error writing output: " + err.Error())
	}

	return nil
}

// findSrcDir locates the source directory containing path.
func findSrcDir(path string) string {
	for _, srcDir := range build.Default.SrcDirs() {
		dir := filepath.Join(srcDir, path)
		if info, err := os.Stat(dir); err == nil && info.IsDir() {
			return dir
		}
	}
	return ""
}

// isRPCService returns a valid identifier if the declaration represents
// an RPC service, otherwise nil.
func isRPCService(decl ast.Decl) *ast.Ident {
	if gen, ok := decl.(*ast.GenDecl); ok && gen.Tok == token.TYPE {
		if strings.Contains(gen.Doc.Text(), "gopherpc:generate") {
			return gen.Specs[0].(*ast.TypeSpec).Name
		}
	}
	return nil
}

func newService(serviceType *types.Named, verbose bool) Service {
	service := Service{Name: serviceType.Obj().Name()}
	if verbose {
		log.Printf("processing service %s", service.Name)
	}

loop:
	for i := 0; i < serviceType.NumMethods(); i++ {
		var (
			m          = serviceType.Method(i)
			sig        = m.Type().(*types.Signature)
			sigParams  = sig.Params()
			sigResults = sig.Results()
		)
		if verbose {
			log.Printf(" -- %s", m.Name())
		}

		if sigParams.Len() != 3 {
			if verbose {
				fmt.Printf("skipping %s.%s because it doesn't have 3 parameters\n", service.Name, m.Name())
			}
			continue loop
		}

		if sigResults.Len() != 1 {
			if verbose {
				fmt.Printf("skipping %s.%s because it doesn't return exactly 1 value\n", service.Name, m.Name())
			}
			continue loop
		}

		if sigResults.At(0).Type().(*types.Named).Obj().Name() != "error" {
			if verbose {
				fmt.Printf("skipping %s.%s because its return value isnt an error\n", service.Name, m.Name())
			}
			continue loop
		}

		var paramTypes []types.Type
		for j := 0; j < 3; j++ {
			if t, ok := sigParams.At(j).Type().(*types.Pointer); !ok {
				if verbose {
					fmt.Printf("skipping %s.%s because parameter %d isn't a pointer\n", service.Name, m.Name(), j)
				}
				continue loop
			} else {
				paramTypes = append(paramTypes, t.Elem())
			}
		}

		if t, ok := paramTypes[0].(*types.Named); !ok || t.Obj().Pkg().Path() != "net/http" || t.Obj().Name() != "Request" {
			if verbose {
				fmt.Printf("skipping %s.%s because its first parameter isn't an *http.Request\n", service.Name, m.Name())
			}
			continue loop
		}

		method := Method{Name: m.Name()}

		param := sig.Params().At(1)
		method.ParamName = param.Name()
		if method.ParamName != "_" {
			switch t := param.Type().(*types.Pointer).Elem().(type) {
			case *types.Named:
				method.ParamType = "*" + t.Obj().Pkg().Name() + "." + t.Obj().Name()
			case *types.Basic:
				method.ParamType = t.Name()
			default:
				log.Fatal("unknown pointer type")
			}
		}

		returnValue := sig.Params().At(2)
		if returnValue.Name() != "_" {
			switch t := returnValue.Type().(*types.Pointer).Elem().(type) {
			case *types.Named:
				method.ReturnType = "*" + t.Obj().Pkg().Name() + "." + t.Obj().Name()
			case *types.Basic:
				method.ReturnType = t.Name()
			default:
				log.Fatal("unknown pointer type")
			}
		}

		service.Methods = append(service.Methods, method)
	}

	return service
}

type Service struct {
	Name    string
	Methods []Method
}

type Method struct {
	Name                 string
	ParamName, ParamType string
	ReturnType           string
}

func (m Method) Params() string {
	if m.ParamType == "" {
		return ""
	}
	return m.ParamName + " " + m.ParamType
}

func (m Method) ParamNameOrNil() string {
	if m.ParamType == "" {
		return "nil"
	}
	return m.ParamName
}

func (m Method) Return() string {
	if m.ReturnType == "" {
		return "error"
	}
	return "(" + m.ReturnType + ", error)"
}
